nameOverride: ""
fullnameOverride: ""

# clusterInternalServiceSuffix allows to override the default ".svc.cluster.local" service address suffix which is used to reach internal services in the cluster.
# Note: It must start with a dot.
# clusterInternalServiceSuffix: .domain.local

replicaCount: 1

rollingUpdate:
  maxSurge: 1
  maxUnavailable: 0

# -- The image to use for this specific deployment and its cron jobs
image:
  # -- Repository, where the Unique service image is pulled from
  # - for Unique internal deployments, these is the internal release repository
  # - for client deployments, this will refer to the client's repository where the images have been mirrored too
  # Note that it is bad practice and not advised to directly pull from Uniques release repository
  # Read in the readme on why the helm chart comes bundled with the unique-ag/chart-testing-service image
  repository: "ghcr.io/unique-ag/chart-testing-service"
  # -- tag, most often will refer one of the latest release of the Unique service
  # Read in the readme on why the helm chart comes bundled with the unique-ag/chart-testing-service image
  tag: "1.0.3"
  # -- pullPolicy, Unique recommends to never use 'Always'
  pullPolicy: IfNotPresent

imagePullSecrets: []

serviceAccount:
  enabled: false
  annotations: {}
  # name: ""
  workloadIdentity: {}

podAnnotations: {}

# -- PodSecurityContext for the pod(s)
podSecurityContext:
  # -- seccompProfile, controls the seccomp profile for the container, defaults to 'RuntimeDefault'
  seccompProfile:
    ## -- type, the type of seccomp profile to use, defaults to 'RuntimeDefault'
    type: RuntimeDefault

# -- SecurityContext for the container(s)
securityContext:
  # -- AllowPrivilegeEscalation, controls if the container can gain more privileges than its parent process, defaults to 'false'
  allowPrivilegeEscalation: false
  # -- readOnlyRootFilesystem, controls if the container has a read-only root filesystem, defaults to 'true'
  readOnlyRootFilesystem: true
  # -- runAsNonRoot, controls if the container must run as a non-root user, defaults to 'true'
  runAsNonRoot: true
  # -- runAsUser, controls the user ID that runs the container, defaults to '1000'
  runAsUser: 1000

deployment:
  enabled: true
  # metadata:
  #   labels:
  #     app: backend-service
  #   annotations:
  #     prometheus: "true"
  # initContainers:
  #   - command:
  #       - sh
  #       - -c
  #       - export MY_VARIABLE="some_value" && sleep 1
  #     volumeMounts:
  #       - name: data
  #         mountPath: /opt
  #         mountPathDeployment: /opt/folder
  #         readOnly: true

service:
  enabled: true
  type: ClusterIP
  port: 8080

# -- Settings for Tyk API Gateway respectively its APIDefinition, note that for now, you need the CRDs installed should you enable this
# ‚ö†Ô∏è Since `2.0.0` this is no longer enabled by default. Unique will slowly migrate away from Tyk API Gateway and into `routes` and `extraRoutes`, refer to the readme.
tyk:
  enabled: false
  # -- ‚ö†Ô∏è When using Tyk API Gateway, you must set a valid listenPath
  listenPath: "/unsert_default_path"
  jwtSource: https://id.unique.app/oauth/v2/keys
  rateLimit:
    {}
    # Limit per interval, example values are default values
    # Rate limit can not be disabled fully only increased, we learned some lessons ü©∏
    # rate: 20 # requests to the key
    # per: 60 # each minute (faster a human can not type)
    # Quota per longer section
    # quotaMax: 15000 # 500 chats per day for 30 days, generous as we are for now
    # quotaRenewalRate: 2592000 # 30 days in seconds
    # If quota or limit gets hit, what happens
    # throttleInterval: -1 # for now we do not throttle
    # throttleRetryLimit: -1 # for now we do not throttle
  # hardTimeouts allows you to increase/decrease timeouts for specific paths
  # hardTimeouts:
  #   - path: "/longer"
  #     method: "GET"
  #     timeoutSeconds: 1000
  exposePublicApi:
    enabled: false
    # appRepositoryUrlOverride: "" # defaults to http://node-app-repository.namespace.svc.cluster.local
    # appRepositoryPortOverride: "" # defaults to 8088
    # appRepositoryNamespaceOverride: "" # defaults to apps
    # publicPathOverride: "" # defaults to '/public'
    # hardTimeouts:
    #   - path: "/longer"
    #     method: "GET"
    #     timeoutSeconds: 1000
  # defaultTimeout: 30 # This setting is only to be modified after consulting the platform team. Disagreed changes will be reverted unquestioned.
  scopedApi:
    enabled: false
    # scopedPathOverride: "" # defaults to '/scoped'
    # hardTimeouts:
    #   - path: "/longer"
    #     method: "GET"
    #     timeoutSeconds: 1000
  # defaultTimeout: 30 # This setting is only to be modified after consulting the platform team. Disagreed changes will be reverted unquestioned.

  # -- blockList allows you to block specific paths and methods
  blockList:
    - methods:
        - GET
      path: /metrics

ingress:
  enabled: false
  tls:
    enabled: false

# env is a flat map of ENV_NAME: $VALUE which will get encapsulated into a ConfigMap and loaded using the envFrom syntax
# It only supports the flat object syntax with key value pairs
env: {}

# envVars is a list of ENV_NAME: $VALUE which will be added to the pods where the $VALUE supports the same syntax as the native pod spec
# https://kubernetes.io/docs/tasks/inject-data-application/define-environment-variable-container/
envVars: []

# extraEnvCM is a list of existing ConfigMaps to be loaded using the envFrom syntax
extraEnvCM: []

# envSecrets is a map of ENV_NAME: $SECRET_VALUE which will get encapsulated into a Secret and loaded using the envFrom syntax
envSecrets: {}

# extraEnvSecrets is a list of existing Secrets to be loaded using the envFrom syntax
extraEnvSecrets: []

probes:
  enabled: true
  liveness:
    httpGet:
      path: /probe
      port: http
    initialDelaySeconds: 10
    periodSeconds: 5
    failureThreshold: 6
  readiness:
    httpGet:
      path: /probe
      port: http
    initialDelaySeconds: 10
    periodSeconds: 5
    failureThreshold: 6
  startup:
    httpGet:
      path: /probe
      port: http
    initialDelaySeconds: 10
    failureThreshold: 30
    periodSeconds: 10

pdb:
  maxUnavailable: 30%

resources: {}

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

nodeSelector: {}

tolerations: []

affinity: {}

volumeMounts: []

volumes: []

auditVolume:
  enabled: false
  mountPath: /audit # defaults to /audit
  capacity: 1Ti # defaults to 1Ti
  attributes:
    resourceGroup: my-azure-resource-group
    storageAccount: my-azure-storage-account
    # containerName: my-azure-container-in-my-azure-storage-account # defaults to release name

# -- cronJob allows you to define a cronJob that mostly bases on the general values.
# Note that since chart version 1.4.0 it is recommended to use preferably extraCronJobs (see readme for more information)
cronJob:
  enabled: false
  name: ""
  suspend: false
  schedule: ""
  timeZone: "Europe/Zurich"
  concurrencyPolicy: Allow
  successfulJobsHistoryLimit: 1
  failedJobsHistoryLimit: 1
  startingDeadlineSeconds: 60
  jobTemplate:
    restartPolicy: OnFailure
    containers:
      name: ""
  env: {}

# -- extraCronJobs allows you to define additional cron jobs besides 'cronJob' itself.
extraCronJobs: []
  # - name: foo
  #   suspend: false
  #   schedule: "0 0 1 1 *"
  #   timeZone: "Europe/Zurich"
  #   concurrencyPolicy: Forbid
  #   restartPolicy: Never
  #   successfulJobsHistoryLimit: 3
  #   failedJobsHistoryLimit: 3
  #   startingDeadlineSeconds: 10
  #   envVars:
  #     - name: RUNNING_MODE
  #       value: "bar"

# !!! usePodIdentity will be deprecated in the future please use useVMManagedIdentity with the clientID
# .Values.secretProvider lets you mount secrets from Azure Key Vault into the pod
# Note that 'vault-1' is the literal vault name from azure
# The line format is 'make <ENV>: from <KEY_VAULT_SECRET_NAME>'
# The conversion from - to _ is done automatically
secretProvider: {}
# Example
# secretProvider:
#   tenantId: 99330c76-81d2-460e-861e-35af8e2a4266
#   aadPodIdBinding: binding-21 # optional, defaults to 'keyvault'
#   useVMManagedIdentity: "true" # optional, if not present usePodIdentity is set to "true" useVMManagedIdentity to "false"
#   userAssignedIdentityID: "xx-pls-provide-client-id-xx"   # Should not be empty if useVMManagedIdentity is present and has the value "true"
#   vaults:
#     vault-name-1:
#       MY_ENV_VARIABLE_1: keyvault-secret-name-a
#     vault-name-2:
#       MY_ENV_VARIABLE_2: keyvault-secret-name-b

prometheus:
  enabled: false
  # enabled: true
  # team: <team-name> # defines alert routing
  # rules:
  #   QNodeChat5xx:
  #     expression: >
  #       sum(
  #         max_over_time(
  #           nestjs_http_server_responses_total{status=~"^5..$", app="node_chat"}[1m]
  #         )
  #         or
  #         vector(0)
  #       )
  #         by (app, path, method, status)
  #       -
  #       sum(
  #         max_over_time(
  #           nestjs_http_server_responses_total{status=~"^5..$", app="node_chat"}[1m]
  #           offset 1m
  #         )
  #         or vector(0)
  #       )
  #         by (app, path, method, status)
  #       > 0
  #     for: 0m
  #     severity: critical
  #     # Left side are alert labels, right side are the metrics labels ($labels.*)
  #     labels:
  #       app: app
  #       path: path
  #       method: method
  #       status: status

hooks:
  migration:
    enabled: false
    # name: "" defaults to db-migration
    command: ""
    # initContainers:
    #   - command:
    #       - sh
    #       - -c
    #       - export MY_VARIABLE="some_value" && sleep 1
    #     volumeMounts:
    #       - name: data
    #         mountPath: /opt
    #         mountPathJob: /opt/folder
    #         readOnly: true

eventBasedAutoscaling:
  enabled: false
  minReplicaCount: 0
  maxReplicaCount: 2
  cron:
    timezone: Europe/Zurich
    start: 0 8 * * 1-5
    end: 0 19 * * 1-5
    desiredReplicas: "1"
  rabbitmq:
    protocol: auto
    # queueName: ""
    mode: QueueLength
    value: "1"
    hostFromEnv: AMQP_URL
  customTriggers: []

externalSecrets:
  []
  # - keyvaultName: my-keyvault
  #   keyvaultURL: "https://my-keyvault:8989" # private keyvault
  #   identityId: "xxx-xxxxxx-xxx-xxxx"
  #   tenantId: "yyyy-yyy-yyyy-yyyy-yy"
  #   secrets:
  #     - name: golden-secret
  #       type: Opaque
  #       metadata:
  #         labels:
  #           app: my-app
  #           environment: production
  #         annotations:
  #           description: "This secret created by external-secrets.io from kv my-keyvault "
  #       data:
  #         - objectName: my-secret-in-kv-1
  #           key: my-secret-in-kv-1

  #         - objectName: my-secret-in-kv-2
  #           key: my-secret-in-kv-2

# -- extraObjects allows you to add additional Kubernetes objects to the manifest. It is the responsibility of the user to ensure that the objects are valid, that they do not conflict with the existing objects and that they are not containing any sensitive information
extraObjects: []

routes:
  gateway:
    name: kong
    namespace: kong-system
  hostnames:
    - chart-testing-service.example.com
  list:
    default:
      enabled: true
      plugins:
        - unique-jwt-auth
    public:
      enabled: true
      plugins:
        - unique-app-repo-auth
    scoped:
      enabled: true
    up:
      enabled: true

# -- BETA: Configure additional gateway routes for the chart here.
# More routes can be added by adding a dictionary key like the 'extra-route-1' route.
# In order for this to install, the Gateway [API CRDs](https://gateway-api.sigs.k8s.io/guides/#getting-started-with-gateway-api) must be installed in the cluster.
extraRoutes:
  extra-route-1:
    # -- Enables or disables the route
    enabled: false
    # -- Set the route apiVersion, e.g. gateway.networking.k8s.io/v1 or gateway.networking.k8s.io/v1alpha2
    apiVersion: gateway.networking.k8s.io/v1
    # -- Set the route kind
    # Valid options are GRPCRoute, HTTPRoute, TCPRoute, TLSRoute, UDPRoute
    kind: HTTPRoute
    # -- Set the route annotations
    annotations: {}
    # -- Set the route labels
    labels: {}
    # -- Add hostnames to the route, will be matched against the host header of the request
    hostnames: []
    # -- parentRefs define the parent gateway(s) that the route will be associated with
    parentRefs:
      - name: kong
        namespace: kong-system
        group: gateway.networking.k8s.io
        kind: Gateway
    # -- which match conditions should be applied to the route
    matches:
      - path:
          type: PathPrefix
          value: /
    ## -- Filters define the filters that are applied to requests that match this rule.
    filters: []
    ## -- Additional custom rules that can be added to the route
    additionalRules: []
